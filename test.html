<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zalo Web Clone - Real-time Messaging</title>
    <!-- Tailwind CSS for modern UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --zalo-blue: #0068ff;
            --zalo-light-blue: #e5f1ff;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        .bg-zalo { background-color: var(--zalo-blue); }
        .text-zalo { color: var(--zalo-blue); }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        #video-grid video { width: 100%; height: 100%; object-fit: cover; background: #2d3748; border-radius: 8px; }
        .message-bubble { max-width: 70%; word-wrap: break-word; }
        .hidden { display: none !important; }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">

    <!-- LOGIN OVERLAY -->
    <div id="auth-screen" class="fixed inset-0 z-50 bg-white flex flex-col items-center justify-center p-4">
        <div class="w-full max-w-md space-y-8 bg-white p-8 rounded-xl shadow-lg border border-gray-100">
            <div class="text-center">
                <h1 class="text-4xl font-bold text-zalo mb-2">Zalo</h1>
                <p class="text-gray-500">Sign in with your phone number</p>
            </div>
            
            <div id="phone-container">
                <label class="block text-sm font-medium text-gray-700">Phone Number</label>
                <div class="mt-1 flex gap-2">
                    <input type="tel" id="phone-number" placeholder="+84 123 456 789" class="block w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-zalo focus:border-zalo">
                </div>
                <div id="recaptcha-container" class="mt-4"></div>
                <button onclick="handlePhoneAuth()" class="mt-4 w-full bg-zalo text-white py-3 rounded-lg font-semibold hover:bg-blue-700 transition">Send OTP</button>
            </div>

            <div id="otp-container" class="hidden">
                <label class="block text-sm font-medium text-gray-700">Verification Code</label>
                <input type="text" id="otp-code" placeholder="123456" class="mt-1 block w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-zalo focus:border-zalo">
                <button onclick="handleVerifyOtp()" class="mt-4 w-full bg-zalo text-white py-3 rounded-lg font-semibold hover:bg-blue-700 transition">Verify & Login</button>
            </div>

            <div id="profile-setup" class="hidden">
                <label class="block text-sm font-medium text-gray-700">Display Name</label>
                <input type="text" id="display-name" placeholder="Your name" class="mt-1 block w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-zalo focus:border-zalo">
                <button onclick="handleProfileSetup()" class="mt-4 w-full bg-green-500 text-white py-3 rounded-lg font-semibold hover:bg-green-600 transition">Start Chatting</button>
            </div>
        </div>
        <p class="mt-8 text-xs text-gray-400 max-w-xs text-center">
            This application is a web-based messaging platform. Message delivery and calling features depend on network and browser support.
        </p>
    </div>

    <!-- MAIN APP LAYOUT -->
    <div id="main-app" class="hidden flex h-screen">
        <!-- Sidebar -->
        <div class="w-20 md:w-80 bg-white border-r flex flex-col">
            <!-- Sidebar Header -->
            <div class="p-4 border-b flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div id="user-avatar" class="w-10 h-10 rounded-full bg-zalo text-white flex items-center justify-center font-bold">U</div>
                    <span id="user-name" class="hidden md:block font-semibold truncate max-w-[120px]">User</span>
                </div>
                <button onclick="logout()" class="text-gray-400 hover:text-red-500"><i data-lucide="log-out" class="w-5 h-5"></i></button>
            </div>

            <!-- Search Bar -->
            <div class="p-3">
                <div class="relative">
                    <input type="text" id="user-search" placeholder="Find by phone..." class="w-full bg-gray-100 rounded-lg py-2 pl-10 pr-4 text-sm focus:outline-none focus:ring-1 focus:ring-zalo">
                    <i data-lucide="search" class="w-4 h-4 absolute left-3 top-2.5 text-gray-400"></i>
                </div>
                <button onclick="searchUser()" class="w-full mt-2 text-xs text-zalo font-medium">Search User</button>
            </div>

            <!-- Conversation List -->
            <div id="chat-list" class="flex-1 overflow-y-auto custom-scrollbar">
                <!-- Chat items will be injected here -->
            </div>
        </div>

        <!-- Chat Content Area -->
        <div class="flex-1 flex flex-col bg-[#f0f2f5]">
            <div id="no-chat-selected" class="flex-1 flex flex-col items-center justify-center text-center p-8">
                <img src="https://cdns.iconmonstr.com/wp-content/releases/preview/2012/240/iconmonstr-speech-bubble-15.png" class="w-32 opacity-10 mb-4" alt="No chat">
                <h2 class="text-xl font-medium text-gray-600">Welcome to Zalo Web</h2>
                <p class="text-gray-400 mt-2">Select a conversation to start messaging</p>
            </div>

            <div id="chat-window" class="hidden flex-1 flex flex-col">
                <!-- Chat Header -->
                <div class="h-16 bg-white border-b px-6 flex items-center justify-between shadow-sm">
                    <div class="flex items-center gap-3">
                        <div id="active-chat-avatar" class="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center font-bold">?</div>
                        <div>
                            <h3 id="active-chat-name" class="font-semibold text-gray-800">Contact Name</h3>
                            <span id="typing-indicator" class="text-xs text-green-500 hidden">typing...</span>
                        </div>
                    </div>
                    <div class="flex items-center gap-4 text-gray-500">
                        <button onclick="initiateCall('voice')" class="p-2 hover:bg-gray-100 rounded-full"><i data-lucide="phone" class="w-5 h-5"></i></button>
                        <button onclick="initiateCall('video')" class="p-2 hover:bg-gray-100 rounded-full"><i data-lucide="video" class="w-5 h-5"></i></button>
                        <button class="p-2 hover:bg-gray-100 rounded-full"><i data-lucide="more-horizontal" class="w-5 h-5"></i></button>
                    </div>
                </div>

                <!-- Messages area -->
                <div id="messages-container" class="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
                    <!-- Messages will be injected here -->
                </div>

                <!-- Input area -->
                <div class="p-4 bg-white border-t">
                    <div class="flex items-end gap-2">
                        <label class="p-2 text-gray-500 hover:text-zalo cursor-pointer">
                            <i data-lucide="paperclip" class="w-6 h-6"></i>
                            <input type="file" id="file-input" class="hidden" onchange="handleFileUpload(this)">
                        </label>
                        <label class="p-2 text-gray-500 hover:text-zalo cursor-pointer">
                            <i data-lucide="image" class="w-6 h-6"></i>
                            <input type="file" id="image-input" accept="image/*" class="hidden" onchange="handleFileUpload(this)">
                        </label>
                        <div class="flex-1 relative">
                            <textarea id="message-input" rows="1" placeholder="Type a message..." class="w-full bg-gray-100 rounded-2xl py-2 px-4 focus:outline-none resize-none" oninput="handleTyping()"></textarea>
                        </div>
                        <button onclick="sendMessage()" class="p-2 bg-zalo text-white rounded-full hover:bg-blue-600 transition">
                            <i data-lucide="send" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CALL MODAL -->
    <div id="call-overlay" class="fixed inset-0 z-[60] bg-slate-900 bg-opacity-95 hidden flex flex-col items-center justify-center p-6">
        <div class="text-white text-center mb-8">
            <h2 id="call-status" class="text-2xl font-light mb-2">Calling...</h2>
            <p id="call-with-name" class="text-lg font-semibold"></p>
        </div>
        
        <div id="video-grid" class="relative w-full max-w-4xl aspect-video grid grid-cols-1 md:grid-cols-2 gap-4">
            <video id="localVideo" autoplay muted playsinline></video>
            <video id="remoteVideo" autoplay playsinline></video>
        </div>

        <div class="mt-12 flex gap-8">
            <button onclick="endCall()" class="bg-red-500 p-4 rounded-full text-white hover:bg-red-600 transition">
                <i data-lucide="phone-off" class="w-8 h-8"></i>
            </button>
            <button id="answer-btn" onclick="answerCall()" class="bg-green-500 p-4 rounded-full text-white hover:bg-green-600 transition hidden">
                <i data-lucide="phone" class="w-8 h-8"></i>
            </button>
        </div>
    </div>

    <!-- FIREBASE & LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, RecaptchaVerifier, signInWithPhoneNumber, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot, query, where, orderBy, addDoc, serverTimestamp, limit } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCLCcgaoW9gNYhKk0c0gDWC6i5mKVTN4XE",
            authDomain: "profile-d1214.firebaseapp.com",
            projectId: "profile-d1214",
            storageBucket: "profile-d1214.firebasestorage.app",
            messagingSenderId: "914980131889",
            appId: "1:914980131889:web:72f8da15c42dbee671b110"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

        let currentUser = null;
        let activeChatId = null;
        let confirmationResult = null;
        let peerConnection = null;
        let localStream = null;

        const servers = {
            iceServers: [{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }]
        };

        // Initialize Lucide Icons
        lucide.createIcons();

        // ---------------- AUTHENTICATION ----------------
        window.handlePhoneAuth = async () => {
            const phoneNumber = document.getElementById('phone-number').value;
            window.recaptchaVerifier = new RecaptchaVerifier(auth, 'recaptcha-container', { 'size': 'normal' });
            
            try {
                confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, window.recaptchaVerifier);
                document.getElementById('phone-container').classList.add('hidden');
                document.getElementById('otp-container').classList.remove('hidden');
            } catch (error) {
                alert(error.message);
            }
        };

        window.handleVerifyOtp = async () => {
            const code = document.getElementById('otp-code').value;
            try {
                const result = await confirmationResult.confirm(code);
                const userDoc = await getDoc(doc(db, "users", result.user.uid));
                if (userDoc.exists()) {
                    completeLogin(result.user);
                } else {
                    document.getElementById('otp-container').classList.add('hidden');
                    document.getElementById('profile-setup').classList.remove('hidden');
                }
            } catch (error) {
                alert("Invalid OTP");
            }
        };

        window.handleProfileSetup = async () => {
            const name = document.getElementById('display-name').value;
            if (!name) return;
            const user = auth.currentUser;
            await setDoc(doc(db, "users", user.uid), {
                uid: user.uid,
                displayName: name,
                phoneNumber: user.phoneNumber,
                phoneNumberHash: btoa(user.phoneNumber), // demo obfuscation
                lastSeen: serverTimestamp()
            });
            completeLogin(user);
        };

        function completeLogin(user) {
            currentUser = user;
            document.getElementById('auth-screen').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');
            loadUserProfile();
            listenForConversations();
            listenForIncomingCalls();
        }

        async function loadUserProfile() {
            const userDoc = await getDoc(doc(db, "users", currentUser.uid));
            const data = userDoc.data();
            document.getElementById('user-name').innerText = data.displayName;
            document.getElementById('user-avatar').innerText = data.displayName[0].toUpperCase();
        }

        window.logout = () => {
            signOut(auth).then(() => location.reload());
        };

        // ---------------- MESSAGING LOGIC ----------------
        window.searchUser = async () => {
            const phone = document.getElementById('user-search').value;
            const q = query(collection(db, "users"), where("phoneNumber", "==", phone));
            const querySnapshot = await getDoc(q);
            // In a real app, use a proper search. For demo, we start chat by ID
            // Simple approach: create conversation ID by sorted UIDs
            alert("Searching logic connected. Use full phone number + country code.");
        };

        async function startConversation(targetUser) {
            const convId = [currentUser.uid, targetUser.uid].sort().join('_');
            await setDoc(doc(db, "conversations", convId), {
                participants: [currentUser.uid, targetUser.uid],
                lastUpdate: serverTimestamp()
            }, { merge: true });
            openChat(convId, targetUser);
        }

        function listenForConversations() {
            const q = query(collection(db, "conversations"), where("participants", "array-contains", currentUser.uid));
            onSnapshot(q, (snapshot) => {
                const chatList = document.getElementById('chat-list');
                chatList.innerHTML = '';
                snapshot.forEach(async (docSnap) => {
                    const data = docSnap.data();
                    const otherId = data.participants.find(id => id !== currentUser.uid);
                    const otherUser = await getDoc(doc(db, "users", otherId));
                    const userData = otherUser.data();
                    
                    const div = document.createElement('div');
                    div.className = "flex items-center gap-3 p-4 hover:bg-gray-50 cursor-pointer border-b border-gray-100 transition";
                    div.onclick = () => openChat(docSnap.id, userData);
                    div.innerHTML = `
                        <div class="w-12 h-12 rounded-full bg-blue-100 text-zalo flex items-center justify-center font-bold">${userData.displayName[0]}</div>
                        <div class="flex-1 overflow-hidden">
                            <h4 class="font-semibold truncate">${userData.displayName}</h4>
                            <p class="text-xs text-gray-500 truncate">${data.lastMessage || 'Start a conversation'}</p>
                        </div>
                    `;
                    chatList.appendChild(div);
                });
            });
        }

        function openChat(convId, otherUser) {
            activeChatId = convId;
            document.getElementById('no-chat-selected').classList.add('hidden');
            document.getElementById('chat-window').classList.remove('hidden');
            document.getElementById('active-chat-name').innerText = otherUser.displayName;
            document.getElementById('active-chat-avatar').innerText = otherUser.displayName[0];
            
            // Listen for messages
            const q = query(collection(db, `conversations/${convId}/messages`), orderBy("timestamp", "asc"), limit(50));
            onSnapshot(q, (snapshot) => {
                const container = document.getElementById('messages-container');
                container.innerHTML = '';
                snapshot.forEach(msgDoc => {
                    renderMessage(msgDoc.data());
                });
                container.scrollTop = container.scrollHeight;
            });
        }

        function renderMessage(msg) {
            const isMe = msg.senderId === currentUser.uid;
            const container = document.getElementById('messages-container');
            const div = document.createElement('div');
            div.className = `flex ${isMe ? 'justify-end' : 'justify-start'}`;
            
            let content = '';
            if (msg.type === 'text') content = `<p>${msg.content}</p>`;
            else if (msg.type === 'image') content = `<img src="${msg.content}" class="rounded-lg max-w-xs cursor-pointer" onclick="window.open('${msg.content}')">`;
            else if (msg.type === 'file') content = `<a href="${msg.content}" target="_blank" class="flex items-center gap-2 bg-white p-2 rounded border"><i data-lucide="file"></i> Attachment</a>`;

            div.innerHTML = `
                <div class="message-bubble px-4 py-2 rounded-2xl ${isMe ? 'bg-zalo-light-blue text-gray-800' : 'bg-white text-gray-800 shadow-sm'}">
                    ${content}
                    <div class="text-[10px] text-gray-400 mt-1 ${isMe ? 'text-right' : ''}">${msg.timestamp?.toDate().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) || ''}</div>
                </div>
            `;
            container.appendChild(div);
            lucide.createIcons();
        }

        window.sendMessage = async () => {
            const input = document.getElementById('message-input');
            const text = input.value.trim();
            if (!text || !activeChatId) return;

            const msgData = {
                senderId: currentUser.uid,
                content: text,
                type: 'text',
                timestamp: serverTimestamp()
            };

            input.value = '';
            await addDoc(collection(db, `conversations/${activeChatId}/messages`), msgData);
            await updateDoc(doc(db, "conversations", activeChatId), { 
                lastMessage: text,
                lastUpdate: serverTimestamp() 
            });
        };

        window.handleFileUpload = async (input) => {
            const file = input.files[0];
            if (!file || !activeChatId) return;

            const type = file.type.startsWith('image/') ? 'image' : 'file';
            const storageRef = ref(storage, `chats/${activeChatId}/${Date.now()}_${file.name}`);
            const uploadTask = uploadBytesResumable(storageRef, file);

            uploadTask.on('state_changed', null, (err) => alert(err), async () => {
                const url = await getDownloadURL(uploadTask.snapshot.ref);
                await addDoc(collection(db, `conversations/${activeChatId}/messages`), {
                    senderId: currentUser.uid,
                    content: url,
                    type: type,
                    timestamp: serverTimestamp()
                });
            });
        };

        // ---------------- WEB RTC CALLING ----------------
        // Note: Signaling implemented via Firestore 'calls' collection
        async function setupWebRTC() {
            peerConnection = new RTCPeerConnection(servers);
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
            document.getElementById('localVideo').srcObject = localStream;

            peerConnection.ontrack = (event) => {
                document.getElementById('remoteVideo').srcObject = event.streams[0];
            };
        }

        window.initiateCall = async (type) => {
            const callId = activeChatId; // Using conversation ID as Call ID for simplicity
            document.getElementById('call-overlay').classList.remove('hidden');
            document.getElementById('call-status').innerText = `Calling (${type})...`;
            
            await setupWebRTC();

            const callDoc = doc(db, "calls", callId);
            const offerCandidates = collection(callDoc, "offerCandidates");
            const answerCandidates = collection(callDoc, "answerCandidates");

            peerConnection.onicecandidate = (event) => {
                event.candidate && addDoc(offerCandidates, event.candidate.toJSON());
            };

            const offerDescription = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offerDescription);

            await setDoc(callDoc, {
                offer: { type: offerDescription.type, sdp: offerDescription.sdp },
                caller: currentUser.uid,
                status: 'ringing',
                type: type
            });

            onSnapshot(callDoc, (snapshot) => {
                const data = snapshot.data();
                if (data?.answer && !peerConnection.currentRemoteDescription) {
                    peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                }
                if (data?.status === 'ended') endCall(false);
            });

            onSnapshot(answerCandidates, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        peerConnection.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                    }
                });
            });
        };

        function listenForIncomingCalls() {
            const q = query(collection(db, "calls"), where("status", "==", "ringing"));
            onSnapshot(q, (snapshot) => {
                snapshot.forEach(async (change) => {
                    const data = change.data();
                    const callId = change.id;
                    // Check if I am part of the conversation this call belongs to
                    if (callId.includes(currentUser.uid) && data.caller !== currentUser.uid) {
                        showIncomingCallUI(callId, data);
                    }
                });
            });
        }

        function showIncomingCallUI(callId, data) {
            document.getElementById('call-overlay').classList.remove('hidden');
            document.getElementById('answer-btn').classList.remove('hidden');
            document.getElementById('call-status').innerText = `Incoming ${data.type} call...`;
            window.currentCallId = callId;
        }

        window.answerCall = async () => {
            const callId = window.currentCallId;
            const callDoc = doc(db, "calls", callId);
            const callData = (await getDoc(callDoc)).data();

            await setupWebRTC();
            document.getElementById('answer-btn').classList.add('hidden');

            const answerCandidates = collection(callDoc, "answerCandidates");
            const offerCandidates = collection(callDoc, "offerCandidates");

            peerConnection.onicecandidate = (event) => {
                event.candidate && addDoc(answerCandidates, event.candidate.toJSON());
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.offer));
            const answerDescription = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answerDescription);

            await updateDoc(callDoc, {
                answer: { type: answerDescription.type, sdp: answerDescription.sdp },
                status: 'connected'
            });

            onSnapshot(offerCandidates, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        peerConnection.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                    }
                });
            });
        };

        window.endCall = async (notify = true) => {
            if (notify && activeChatId) {
                await updateDoc(doc(db, "calls", activeChatId), { status: 'ended' });
            }
            if (localStream) localStream.getTracks().forEach(t => t.stop());
            if (peerConnection) peerConnection.close();
            document.getElementById('call-overlay').classList.add('hidden');
            document.getElementById('remoteVideo').srcObject = null;
            document.getElementById('localVideo').srcObject = null;
        };

        // Listen for auth state
        onAuthStateChanged(auth, (user) => {
            if (user) completeLogin(user);
        });

    </script>
</body>
</html>
